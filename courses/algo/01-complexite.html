<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../../styles/courses.css">

    <title>Chapitre 1 - Complexité</title>
</head>
<body>
    <h1>Chapitre 1 - Complexité</h1>

    <p class="last-update">Dernière mise à jour : 30/09/2025</p>

    <div class="contents">
        <p><b>Table des Matières</b></p>

        <ol>
            <li><a href="#algorithmique">Algorithmique</a></li>
            <li><a href="#langage-java">Langage Java</a></li>
            <li><a href="#types-de-fonctions">Types de Fonctions</a></li>
            <li><a href="#complexite">Complexité</a></li>
            <li><a href="#memoisation">Mémoisation</a></li>
            <li><a href="#exercices">Exercices</a></li>
        </ol>
    </div>


    <h2 id="algorithmique">Algorithmique</h2>

    <p>Un <b>algorithme</b> est une séquence finie d'instructions rigoureuses permettant de résoudre un problème ou d'accomplir une tâche donnée. En d'autres termes, un algorithme est une méthode systématique qui, en partant de données en entrée, décrit étape par étape les actions à effectuer pour produire des données de sortie.</p>

    <p>Il est important en premier lieu d'abstraire un algorithme de tout langage de programmation. En effet, bien qu'on emploie souvent des langages de programmation pour implémenter des algorithmes, ils peuvent également être décrits de divers autres façons : en langage naturel, avec du pseudocode, etc.</p>

    <p>Comme exemple, supposons que l'on aimerait résoudre un problème : <b>calculer la somme de deux nombres</b>. Nous pouvons implémenter un algorithme qui va décrire les étapes à effectuer pour résoudre ce problème.</p>

    <p>Nous pouvons tout d'abord représenter cet algorithme en <b>langage naturel</b> (français dans notre cas), un peu comme une recette de cuisine :</p>

    <ul>
        <li>Etape 1 : lire les valeurs de <code>a</code> et <code>b</code> données en entrée. On suppose que <code>a</code> et <code>b</code> représentent les deux nombres.</li>
        <li>Etape 2 : calculer la somme de <code>a</code> et de <code>b</code>.</li>
        <li>Etape 3 : affichier la somme obtenue.</li>
        <li>Etape 4 : fin des étapes.</li>
    </ul>

    <p>Ce formalisme est très clair pour un humain, mais ce n'est pas très formel. Nous pouvons rendre cet algorithme plus formel en le représentant avec du <b>pseudocode</b> :</p>

    <pre>
    ALGORITHM: sumTwoNumbers
    INPUT: a (integer) and b (integer)
    OUTPUT: sum of a and b (integer)

    BEGIN
        READ a, b
        SUM = a + b
        PRINT SUM
    END
    </pre>

    <p>L'algorithme est à présent représenté de façon beaucoup plus formelle. Cependant, ce pseudocode mélange du langage naturel et des conventions de nommage logiques/de programmation, ce qui n'est pas lisible par un ordinateur. Pour ce faire, nous pouvons aller encore plus loin et représenter l'algorithme avec le <b>langage de programmation</b> Java :</p>

    <pre>
    int sumTwoNumbers(int a, int b) {
        int sum = a + b;
        System.out.println("The sum is: " + sum);
        return sum;
    }
    </pre>

    <p>En conclusion, nous avons réalisé un algorithme permettant de résoudre le problème du calcul de la somme de deux nombres. Nous avons implémenté cet algorithme de trois façons différentes : en langage naturel, en pseudocode, et en langage de programmation. Bien que la façon idéale de représenter un algorithme en informatique soit d'utiliser un langage de programmation, il est souvent utile de d'abord représenter un algorithme en langage naturel ou en pseudocode afin d'avoir une idée globale de son fonctionnement.</p>


    <h2 id="langage-java">Langage Java</h2>

    <p class="info">Dans le cadre de ce cours, nous allons utiliser le langage de programmation Java pour implémenter des algorithmes. Il est important de noter qu'on ne vous demande pas d'être des professionnels du langage. Ce qui compte surtout, c'est de comprendre les concepts liés aux algorithmes : savoir décomposer un problème, concevoir les étapes, spécifier, organiser les instructions, etc. Une fois que ces notions sont bien assimilées, il devient beaucoup plus facile de passer d'un langage à un autre (car les idées fondamentales restent les mêmes). Maîtriser les concepts liés aux algorithmes est bien plus précieux que de mémoriser la syntaxe de Java !</p>

    <p><b>Type primitif</b> : <code>int</code> (entier), <code>boolean</code> (vrai/faux), <code>char</code> (caractère), <code>float</code>, <code>double</code>, etc.</p>

    <p><b>Type non-primitif (objet)</b> : <code>String</code> (chaine de caractères), <code>int[]</code> (tableau d'entiers), <code>String[]</code> (tableau de chaines de caracères), etc.</p>

    <p><b>Opération mathématique</b> : <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo), etc.</p>

    <p><b>Expression logique</b> : <code>&&</code> (AND), <code>||</code> (OR), <code>!</code> (négation), etc.</p>

    <p><b>Commentaire</b> :</p>

    <pre>
    // this is a single line comment

    /*
    this is
    a multiline
    comment
    */
    </pre>

    <p><b>Variable</b> :</p>

    <pre>
    int nb = 10;
    boolean exists = false;
    String[] cars = {"audi", "bmw", "skoda"};
    </pre>

    <p><b>Tableau</b> :</p>

    <pre>
    int[] numbers = {1, 2, 3, 4};
    System.out.println(numbers[0]); // prints the first element of numbers (1)
    </pre>

    <p><b>Condition</b> :</p>

    <pre>
    if(a > 0) {
        System.out.println("a is positive");
    }
    else {
        System.out.println("a is negative or 0");
    }
    </pre>

    <p><b>Boucle for</b> :</p>

    <pre>
    for(int i = 0; i < 10; i++) {
        System.out.println(i);
    }
    </pre>

    <p><b>Boucle while</b> :</p>

    <pre>
    while(a > 0) {
        a--;
    }
    </pre>

    <p><b>Fonction</b> :</p>

    <pre>
    public static int sum(int x, int y) {
        return x + y;
    }
    </pre>

    <p><b>Récursion</b> :</p>

    <pre>
    public static int factorial(int n) {
        if(n == 0 || n == 1) {
            return 1; // base case
        }
        else {
            return n * factorial(n - 1); // recursive call
        }
    }
    </pre>

    <p>L'ensemble de ces concepts en Java devraient déjà consister en une bonne base pour commencer à implémenter des algorithmes.</p>


    <h2 id="types-de-fonctions">Types de Fonctions</h2>

    <p>Afin d'implémenter un algorithme, on va souvent devoir boucler (itérer plusieurs fois) pour résoudre le problème associé. En effet, plein de problèmes en ont besoin : trouver le minimum dans une liste, trier les éléments d'un tableau, etc. Dans les langages de programmation, on va pouvoir implémenter des fonctions qui bouclent de deux façons différentes :</p>

    <ul>
        <li><b>Fonction itérative</b> : fonction impliquant une boucle (de type <code>for</code> ou <code>while</code>) répétant des instructions jusqu'à ce qu'une certaine condition est atteinte.</li>
        <li><b>Fonction récursive</b> : fonction s'appelant elle-même jusqu'à ce qu'une certaine condition est atteinte. Il faut souvent utiliser plus de paramèters pour transmettre de l'information mise à jour dans les prochaines récursions.</li>
    </ul>

    <p>Souvent, l'itération et la récursion sont interchangeables.</p>


    <h2 id="complexite">Complexité</h2>

    <p>Vu que les ressources disponibles d'un ordinateur ne sont (pas encore) illimitées, il est important d'implémenter des algorithmes qui en prennent compte. Donc, lorsqu'on implémente un algorithme, on va mesurer son efficacité sur base de sa consommation en ressources.</p>

    <p>La <b>complexité</b> algorithmique est une manière de mesurer l'efficacité d'un algorithme. Elle permet de savoir combien de <b>temps de calcul</b> ou combien de d'<b>espace mémoire</b> un algorithme va utiliser en fonction de la taille de son entrée (souvent représentée par <code>n</code>). Par exemple, si on a un algorithme qui trie une liste de <code>n</code> entiers, la complexité nous aide à estimer combien d'opérations seront nécessaires quand <code>n</code> devient très grand. La complexité aide notamment à comparer l'efficacité de différents algorithmes, et de choisir le plus adapté à un problème donné.</p>

    <p>Selon la ressource, on peut mesurer deux types de complexités :</p>

    <ul>
        <li><b>Complexité en temps</b> : indique combien d'opérations l'algorithme va effectuer.</li>
        <li><b>Complexité en espace</b> : indique combien de mémoire l'algorithme va utiliser.</li>
    </ul>

    <p>On utilisera la notation grand <code>O</code> pour représenter la complexité d'un algorithme en fonction des entrées <code>n</code>. Par exemple, <code>O(n)</code> représente une complexité linéaire. Afin de comprendre l'impact de la complexité d'un algorithme, on peut visualiser le schéma suivant :</p>

    <img class="image" src="../../images/big-o-cheat-sheet.png" alt="Image">

    <p>On peut comprendre comment le temps ou l'espace utilisé par un algorithme augmente quand la taille de l'entrée <code>n</code> augmente, et donc en conséquence l'importance d'optimiser les implémentations d'algorithmes.</p>

    <p>Lorsqu'on implémente des algorithmes, on retrouve parfois des complexités "types" qui ont leur propre nom :</p>

    <ul>
        <li><code>O(1)</code> : complexité <b>constante</b>.</li>
        <li><code>O(log n)</code> : complexité <b>logarithmique</b>.</li>
        <li><code>O(n)</code> : complexité <b>linéaire</b>.</li>
        <li><code>O(n log n)</code> : complexité <b>linéarithmique</b> ou <b>loglinéaire</b>.</li>
        <li><code>O(n^2)</code> : complexité <b>quadratique</b>.</li>
        <li><code>O(2^n)</code> : complexité <b>exponentielle</b>.</li>
        <li><code>O(n!)</code> : complexité <b>factorielle</b>.</li>
    </ul>

    <p>Il est possible de calculer la complexité d'un algorithme à partir de son code. L'idée est d'analyser le nombre d'opérations effectuées en fonction de la taille de l'entrée <code>n</code>.</p>

    <p><b>Opérations constantes</b> : les opérations qui ne dépendent pas de <code>n</code> ont une complexité constante <code>O(1)</code>, car peu importe la taille de l'entrée <code>n</code>, ces opérations prendront toujours le même temps à exécuter.</p>

    <pre>
    public static void test(int n) {
        int a = 2;               // O(1)
        int b = 100000 * 2 / 10; // O(1)
        int c = 10 + n;          // Also O(1) because insignificant
    }
    </pre>

    <p><b>Conditions</b> : lorsqu'une condition <code>if</code> pourrait mener vers une complexité très élevée, on la considère car on prend toujours le "pire cas possible" pour le calcul de la complexité.</p>

    <pre>
    public static void test(int n, int a) {
        if(a > 10) { // O(n^2) ; We consider this as it is the worst case possible
            // Execute n^2 operations
        }
        else { // O(1)
            // Execute 1 operation
        }
    }
    </pre>

    <p><b>Boucles</b> : lorsqu'une boucle itère en fonction de la taille d'entrée <code>n</code>, sa complexité correspond également au nombre d'itérations <code>n</code>. Il faut faire attention car certaines boucles peuvent itérer plus rapidement et donc ont une complexité inférieure à <code>n</code>. Lorsque des boucles sont imbriquées, on multiplie leurs complexités.</p>

    <pre>
    public static void test(int n) {
        // O(n)
        for(int i = 0; i < n; i++) { // we iterate n times
            // code
        }

        // O(n) * O(n) = O(n^2)
        for(int i = 0; i < n; i++) { // we iterate n times
            for(int j = 0; j < n; i++) { // we iterate n times
                // code
            }
        }

        // O(log n)
        for(int i = 1; i < n; i *= 2) { // we iterate log n times
            // code
        }
    }
    </pre>

    <p><b>Récursions</b> : pour calculer la complexité d'un programme contenant de la récursion, on utilise des <b>équations récurrentes</b>.</p>

    <img class="image" src="../../images/equations-recurrentes.png" alt="Image">

    <p>Pour trouver la forme de l'équation, on regarde la forme de la récursion <code>cT(...)</code> et la forme du reste du code <code>bn^k</code>. En fonction de l'équation récurrente formée, on peut trouver la complexité finale à l'aide du tableau.</p>

    <p><b>Simplifications</b> : il existe des règles à appliquer pour trouver la forme générale d'une complexité.</p>

    <img class="image" src="../../images/regles-o.png" alt="Image">

    <p><b>Formules log</b> : il existe également des formules pour transformer/simplifier des expressions logarithmiques.</p>

    <img class="image" src="../../images/regles-log.png" alt="Image">


    <h2 id="memoisation">Mémoisation</h2>

    <p>La <b>mémoisation</b> est une technique d'optimisation pour les algorithmes récursifs (qui recalculent souvent les mêmes résultats). L'idée est simple : stocker les résultats déjà calculés dans une structure (tableau, liste, dictionnaire, etc.) pour ne pas devoir les recalculer. Cela permet souvent de réduire la complexité des algorithmes récursifs qui explorent plusieurs fois les mêmes sous-problèmes.</p>

    <p>Par exemple, nous pouvons appliquer le principe de mémoisation à une fonction récursive qui calcule la suite de Fibonacci :</p>

    <pre>
    public static int fibonacciMemo(int n, int[] memo) {
        if(n <= 1) {
            return n;  // base case
        }

        if(memo[n] != -1) {
            return memo[n];  // case when the result is already in the memo
        }

        memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);

        return memo[n];
    }
    </pre>

    <p>On peut voir une illustration du principe de mémoisation pour Fibonacci ci-dessous :</p>

    <img class="image" src="../../images/memoisation-fibonacci-example.png" alt="Image">


    <h2 id="exercices">Exercices</h2>


    <h3>1. Algorithmes</h3>

    <p>Implémentez des algorithmes en langage naturel, pseudocode, et en Java pour résoudre les problèmes suivants :</p>

    <details>
        <summary>1.1. Trouver le maximum entre deux entiers.</summary>
        <pre>
    public static int max(int a, int b) {
        if(a > b) {
            return a;
        }
        else {
            return b;
        }
    }
        </pre>
    </details>

    <details>
        <summary>1.2. Afficher tous les entiers inférieurs à un entier donné.</summary>
        <pre>
    public static void printNumbersBelow(int x) {
        if(x <= 0) {
            System.out.println("No numbers to display");
            return;
        }
        for(int i = 0; i < x; i++) {
            System.out.println(i);
        }
    }
        </pre>
    </details>

    <details>
        <summary>1.3. Déterminer si un entier est pair ou impair.</summary>
        <pre>
    public static boolean isEven(int x) {
        return n % 2 == 0;
    }
        </pre>
    </details>


    <h3>2. Itération et Récursion</h3>

    <p>Implémentez des algorithmes en Java dans des fonctions itératives et récursives pour résoudre les problèmes suivants :</p>

    <details>
        <summary>2.1. Renvoyer la valeur minimale d'un tableau d'entiers.</summary>
        <p>Fonction itérative :</p>
        <pre>
    public static int tabMinIterative(int[] tab) {
        int minValue = tab[0];

        for(int index = 1; index < tab.length; index++) {
            if(tab[index] < minValue) {
                minValue = tab[index];
            }
        }

        return minValue;
    }
        </pre>
        <p>Fonction récursive :</p>
        <pre>
    public static int tabMinRecursive(int[] tab, int index) {
        if(index == 0) {
            return tab[0];
        }

        int minValue = tabMinRecursive(tab, index - 1);

        if(minValue < tab[index]) {
            return minValue;
        }
        else {
            return tab[index];
        }
    }
        </pre>
    </details>

    <details>
        <summary>2.2. Étant donné un nombre <code>n</code>, calculer la somme de <code>1</code> à <code>n</code>.</summary>
        <p>Fonction itérative :</p>
        <pre>
    public static int sumIterative(int n) {
        int sum = 0;

        for(int i = 1; i <= n; i++) {
            sum += i;
        }

        return sum;
    }
        </pre>
        <p>Fonction récursive :</p>
        <pre>
    public static int sumRecursive(int n) {
        if (n <= 0) {
            return 0;
        }

        return n + sumRecursive(n - 1);
    }
        </pre>
    </details>

    <details>
        <summary>2.3. Inverser une chaîne de caractères.</summary>
        <p>Solution</p>
    </details>

    <h3>3. Complexité</h3>

    <details>
        <summary>3.1. Simplifiez l'ordre de grandeur suivant : <code>log(n^2) + (log(2^n))^2 + log(4^n) + n * log(n)</code></summary>
        <p><code>2logn + (nlog2)^2 + nlog4 + n * logn</code></p>
        <p><code>2logn + (n * 1)^2 + (n * 0.6) + n * logn</code></p>
        <p><code>2logn + n^2 + 0.6n + nlogn</code></p>
        <p><code>logn + n^2 + n + nlogn</code></p>
        <p><code>O(n^2)</code>, car <code>n^2</code> est la complexité la plus élevée.</p>
    </details>

    <details>
        <summary>
            3.2. Donnez la complexité en temps de la fonction suivante :
            <pre>
    public static int myFunc(int n) {
        int u = 0;

        for(int i = 0; i <= n * n; i++) {
            u = i;
            while(u > 1) {
                u = u / 2;
            }
        }

        return u;
    }
            </pre>
        </summary>
        <pre>
    public static int funcA(int n) {
        int u = 0; // 1

        for(int i = 0; i <= n * n; i++) { // n^2
            u = i; // 1
            while(u > 1) { // log n
                u = u / 2; // 1
            }
        }

        return u; // 1
    }
        </pre>
        <p>On omet les complexités constantes de type <code>O(1)</code>, et on multiplie les complexités des boucles imbriquées : <code>O(n^2) * O(log n)</code>. On obtient donc la complexité en temps <code>O(n^2 log n)</code> (loglinéaire quadratique).</p>
    </details>

    <details>
        <summary>
            3.3. Donnez la complexité en temps de la fonction suivante :
            <pre>
    public static int funcB(int n) {
        int r = 0;

        if(n > 4) {
            for(int i = 0; i < 4; i++) {
                r = r + funcB(n/2);
            }
        }

        for(int i = 1; i < n; i *= 2) {
            for(int j = 0; j < n; j++) {
                for(int k = j; k < n; k += 2) {
                    r += i + j * k;
                }
            }
        }

        return r;
    }
            </pre>
        </summary>
        <pre>
    public static int funcB(int n) {
        int r = 0; // 1

        if(n > 4) { // Worst case, enter if
            for(int i = 0; i < 4; i++) { // 4
                r = r + funcB(n/2); // T(n/2)
            }
        }

        for(int i = 1; i < n; i *= 2) { // log n
            for(int j = 0; j < n; j++) { // n
                for(int k = j; k < n; k += 2) { // n/2
                    r += i + j * k; // 1
                }
            }
        }

        return r; // 1
    }
        </pre>
        <p>Forme de la récursion <code>cT(n/d)</code> : <code>4T(n/2)</code>.</p>
        <p>Forme du reste du code <code>bn^k</code> : <code>log n * n * n/2 = n^2 log n</code> (<code>n/2</code> se transforme en <code>n</code> car on omet la constante <code>2</code>).</p>
        <p>On obtient l'équation récurrente : <code>4T(n/2) + n^2 log n</code>, ce qui correspond à la condition <code>c = d^k <=> 4 = 2^2</code>.</p>
        <p>Ce qui correspond à la complexité <code>O(n^2 log n)</code>.</p>
    </details>


    <h3>4. Mémoisation</h3>

    <details>
        <summary>4.1. Mémoisez le programme suivant :</summary>
    </details>


    <div class="license">
        <p>&copy; 2025 Alix Decrop. Le contenu de cette page est mis à disposition selon les termes de la license <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution - CC BY-NC-ND 4.0</a>. En gros, vous êtes libres de copier/redistribuer le contenu de cette page, sans utilisation commerciale ni modifications.</p>

        <img src="../../images/license.png" alt="CC BY-NC-ND 4.0 License Image">
    </div>
</body>
</html>